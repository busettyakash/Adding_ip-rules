name: Configure Argo CD on AKS with HTTPS

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  argo-cd-setup:
    runs-on: ubuntu-latest
    env:
      KUBECONFIG: ${{ github.workspace }}/kubeconfig

    steps:
      # --- Checkout ---
      - name: Checkout repository
        uses: actions/checkout@v3

      # --- Azure Login (OIDC) ---
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # --- Get AKS Credentials ---
      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --file $KUBECONFIG --overwrite-existing
          kubectl config view

      # --- Verify cluster connectivity ---
      - name: Verify AKS Connection
        run: kubectl get nodes

      # --- Ensure Argo CD namespace ---
      - name: Ensure Argo CD Namespace
        run: |
          kubectl create namespace gvk-argocd --dry-run=client -o yaml | kubectl apply -f -

      # --- Install NGINX Ingress Controller ---
      - name: Install NGINX Ingress
        run: |
          if ! kubectl get ns ingress-nginx >/dev/null 2>&1; then
            echo "üì¶ Installing NGINX Ingress..."
            kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
            kubectl wait --for=condition=Available deployment/ingress-nginx-controller -n ingress-nginx --timeout=300s
          else
            echo "‚úÖ NGINX Ingress already installed."
          fi

      # --- Install Argo CD ---
      - name: Install Argo CD
        run: |
          if ! kubectl get deployment -n gvk-argocd argocd-server >/dev/null 2>&1; then
            echo "üì¶ Installing Argo CD..."
            kubectl apply -n gvk-argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          else
            echo "‚úÖ Argo CD already installed."
          fi

      # --- Install Cert-Manager ---
      - name: Install Cert-Manager
        run: |
          kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml
          kubectl rollout status deployment/cert-manager -n cert-manager --timeout=180s
          kubectl rollout status deployment/cert-manager-webhook -n cert-manager --timeout=180s
          kubectl rollout status deployment/cert-manager-cainjector -n cert-manager --timeout=180s

      # --- Wait for Cert-Manager Webhook Ready ---
      - name: Wait for Cert-Manager Webhook
        run: |
          echo "‚è≥ Waiting for cert-manager webhook..."
          kubectl rollout status deployment/cert-manager-webhook -n cert-manager --timeout=180s
          echo "‚úÖ Webhook ready."

      # --- Create ClusterIssuer (Let‚Äôs Encrypt) ---
      - name: Create ClusterIssuer
        run: |
          echo "üìú Creating ClusterIssuer for Let's Encrypt..."
          for i in {1..10}; do
            if kubectl apply -f - <<EOF; then
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: letsencrypt
spec:
  acme:
    email: ${{ secrets.LETSENCRYPT_EMAIL }}
    server: https://acme-v02.api.letsencrypt.org/directory
    privateKeySecretRef:
      name: letsencrypt-private-key
    solvers:
      - http01:
          ingress:
            class: nginx
EOF
              echo "‚úÖ ClusterIssuer applied successfully."
              break
            else
              echo "‚ö†Ô∏è Retry applying ClusterIssuer (attempt $i)..."
              sleep 15
            fi
            if [ $i -eq 10 ]; then
              echo "‚ùå Failed to apply ClusterIssuer after multiple attempts."
              exit 1
            fi
          done

      # --- Create Argo CD Ingress ---
      - name: Create Argo CD Ingress
        run: |
          DOMAIN="${{ secrets.PUBLIC_DOMAIN }}"
          cat <<EOF | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: argocd-server-ingress
  namespace: gvk-argocd
  annotations:
    kubernetes.io/ingress.class: nginx
    cert-manager.io/cluster-issuer: letsencrypt
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/backend-protocol: "HTTPS"
spec:
  rules:
    - host: ${DOMAIN}
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: argocd-server
                port:
                  number: 443
  tls:
    - hosts:
        - ${DOMAIN}
      secretName: argocd-tls
EOF

      # --- Wait for Argo CD Server Pod ---
      - name: Wait for Argo CD Server
        run: |
          kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=argocd-server -n gvk-argocd --timeout=300s

      # --- Wait for Certificate to be Ready ---
      - name: Wait for TLS Certificate
        run: |
          for i in {1..20}; do
            if kubectl get certificate argocd-tls -n gvk-argocd >/dev/null 2>&1; then
              echo "‚úÖ Certificate resource found."
              break
            fi
            echo "‚è≥ Waiting for Certificate resource..."
            sleep 30
          done
          kubectl wait --for=condition=Ready certificate/argocd-tls -n gvk-argocd --timeout=600s
          echo "‚úÖ TLS certificate issued successfully."

      # --- Set Argo CD Admin Password ---
      - name: Set Argo CD Admin Password
        run: |
          sudo apt-get update && sudo apt-get install -y apache2-utils
          HASH=$(htpasswd -bnBC 10 "" "${{ secrets.ARGOCD_ADMIN_PASSWORD }}" | tr -d ':\n')
          kubectl -n gvk-argocd patch secret argocd-secret \
            -p "{\"stringData\": {\"admin.password\": \"$HASH\", \"admin.passwordMtime\": \"$(date +%FT%T%Z)\"}}"
          echo "‚úÖ Admin password updated."

      # --- Get LoadBalancer IP and Update DNS ---
      - name: Update Azure DNS Record
        run: |
          DOMAIN=${{ secrets.PUBLIC_DOMAIN }}
          DNS_ZONE=${{ secrets.AZURE_DNS_ZONE }}
          RG=${{ secrets.AZURE_DNS_RESOURCE_GROUP }}
          IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "üåê LoadBalancer IP: $IP"
          az network dns record-set a create -g "$RG" -z "$DNS_ZONE" -n "${DOMAIN%%.$DNS_ZONE}"
          az network dns record-set a add-record -g "$RG" -z "$DNS_ZONE" -n "${DOMAIN%%.$DNS_ZONE}" -a "$IP"
          echo "‚úÖ DNS A record updated for $DOMAIN"

      # --- Output final URL ---
      - name: Output Argo CD URL
        run: |
          echo "üåê Argo CD URL: https://${{ secrets.PUBLIC_DOMAIN }}"
          echo "üîë Username: admin"
          echo "üîë Password: ${{ secrets.ARGOCD_ADMIN_PASSWORD }}"
