name: Deploy Argo CD on AKS with HTTPS

on:
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

jobs:
  argo-cd-setup:
    runs-on: ubuntu-latest
    env:
      KUBECONFIG: ${{ github.workspace }}/kubeconfig
      LETSENCRYPT_EMAIL: ${{ secrets.LETSENCRYPT_EMAIL }}
      PUBLIC_DOMAIN: ${{ secrets.PUBLIC_DOMAIN }} # e.g., gvk.argocd.platform.com
      AZURE_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
      AZURE_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
      AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
      AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      AZURE_DNS_RESOURCE_GROUP: ${{ secrets.AZURE_DNS_RESOURCE_GROUP }}
      AZURE_DNS_ZONE: ${{ secrets.AZURE_DNS_ZONE }}
      STATIC_IP_NAME: ingress-static-ip
      ARGOCD_ADMIN_PASSWORD: ${{ secrets.ARGOCD_ADMIN_PASSWORD }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Azure Login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Get AKS credentials
        run: |
          az aks get-credentials \
            --resource-group ${{ secrets.AKS_RESOURCE_GROUP }} \
            --name ${{ secrets.AKS_CLUSTER_NAME }} \
            --file $KUBECONFIG --overwrite-existing
          kubectl config view

      - name: Verify AKS Cluster
        run: kubectl get nodes

      - name: Ensure Namespaces
        run: |
          kubectl create namespace gvk-argocd --dry-run=client -o yaml | kubectl apply -f -
          kubectl create namespace cert-manager --dry-run=client -o yaml | kubectl apply -f -

      - name: Install NGINX Ingress
        run: |
          if ! kubectl get ns ingress-nginx >/dev/null 2>&1; then
            kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
          fi
          kubectl rollout status deployment/ingress-nginx-controller -n ingress-nginx --timeout=300s

      - name: Set or create NGINX Public IP
        shell: bash
        env:
          STATIC_IP_NAME: ${{ env.STATIC_IP_NAME }}
          RG: ${{ secrets.AZURE_DNS_RESOURCE_GROUP }}
        run: |
          # Try to get existing public IP
          STATIC_IP=$(az network public-ip show -g "$RG" -n "$STATIC_IP_NAME" --query ipAddress -o tsv 2>/dev/null || echo "")
          
          if [ -n "$STATIC_IP" ]; then
            echo "‚úÖ Using existing public IP: $STATIC_IP"
          else
            echo "No existing static IP found, attempting to create one..."
            set +e
            STATIC_IP=$(az network public-ip create \
              -g "$RG" \
              -n "$STATIC_IP_NAME" \
              --sku Standard \
              --allocation-method static \
              --query publicIp.ipAddress -o tsv 2>/dev/null)
            if [ -n "$STATIC_IP" ]; then
              echo "‚úÖ Created new static IP: $STATIC_IP"
            else
              echo "‚ö†Ô∏è Could not create static IP (limit reached). Will use dynamic IP assigned by Azure."
              STATIC_IP=""
            fi
            set -e
          fi

          echo "STATIC_IP=$STATIC_IP" >> $GITHUB_ENV

      - name: Patch NGINX Ingress with Public IP (if available)
        shell: bash
        run: |
          if [ -n "$STATIC_IP" ]; then
            echo "Patching NGINX Ingress to use static IP $STATIC_IP"
            kubectl patch svc ingress-nginx-controller -n ingress-nginx \
              -p "{\"spec\": {\"type\": \"LoadBalancer\", \"loadBalancerIP\": \"$STATIC_IP\"}}"
          else
            echo "No static IP, using dynamic IP from Azure LoadBalancer"
            kubectl patch svc ingress-nginx-controller -n ingress-nginx \
              -p '{"spec": {"type": "LoadBalancer"}}'
          fi

      - name: Install Argo CD
        run: |
          if ! kubectl get deployment -n gvk-argocd argocd-server >/dev/null 2>&1; then
            kubectl apply -n gvk-argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
          fi
          kubectl rollout status deployment/argocd-server -n gvk-argocd --timeout=300s

      - name: Install Cert-Manager
        run: |
          kubectl apply -f https://github.com/cert-manager/cert-manager/releases/latest/download/cert-manager.yaml
          kubectl rollout status deployment/cert-manager -n cert-manager --timeout=180s
          kubectl rollout status deployment/cert-manager-webhook -n cert-manager --timeout=180s
          kubectl rollout status deployment/cert-manager-cainjector -n cert-manager --timeout=180s

      - name: Create Azure DNS Secret
        run: |
          kubectl create secret generic azure-dns-secret \
            --from-literal=client-secret="${{ secrets.AZURE_CLIENT_SECRET }}" \
            -n cert-manager --dry-run=client -o yaml | kubectl apply -f -

      - name: Apply ClusterIssuer
        run: |
          envsubst '${LETSENCRYPT_EMAIL} ${AZURE_CLIENT_ID} ${AZURE_CLIENT_SECRET} ${AZURE_TENANT_ID} ${AZURE_SUBSCRIPTION_ID} ${AZURE_DNS_RESOURCE_GROUP} ${AZURE_DNS_ZONE}' < k8s/clusterissuer.yaml | kubectl apply -f -

      - name: Apply Argo CD Ingress
        run: |
          envsubst '${PUBLIC_DOMAIN}' < k8s/argocd-ingress.yaml | kubectl apply -f -

      - name: Wait for Argo CD Server Pod
        run: |
          kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=argocd-server -n gvk-argocd --timeout=300s

      - name: Wait for TLS Certificate
        run: |
          RETRIES=20
          for i in $(seq 1 $RETRIES); do
            STATUS=$(kubectl get certificate argocd-tls -n gvk-argocd -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}')
            if [ "$STATUS" == "True" ]; then
              echo "‚úÖ Certificate is ready!"
              break
            else
              echo "Attempt $i: Certificate not ready yet. Waiting 30s..."
              sleep 30
            fi
          done

      - name: Set Argo CD Admin Password
        run: |
          sudo apt-get update && sudo apt-get install -y apache2-utils
          HASH=$(htpasswd -bnBC 10 "" "${{ secrets.ARGOCD_ADMIN_PASSWORD }}" | tr -d ':\n')
          kubectl -n gvk-argocd patch secret argocd-secret \
            -p "{\"stringData\": {\"admin.password\": \"$HASH\", \"admin.passwordMtime\": \"$(date +%FT%T%Z)\"}}"

      - name: Update DNS with Public IP
        shell: bash
        env:
          STATIC_IP: ${{ env.STATIC_IP }}
          DOMAIN: ${{ secrets.PUBLIC_DOMAIN }}
          DNS_ZONE: ${{ secrets.AZURE_DNS_ZONE }}
          RG: ${{ secrets.AZURE_DNS_RESOURCE_GROUP }}
        run: |
          # If STATIC_IP is empty, wait for dynamic IP
          if [ -z "$STATIC_IP" ]; then
            echo "Waiting for dynamic LoadBalancer IP..."
            MAX_ATTEMPTS=40
            SLEEP_SECONDS=15
            for i in $(seq 1 $MAX_ATTEMPTS); do
              STATIC_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
              if [ -n "$STATIC_IP" ]; then
                echo "Ingress IP found: $STATIC_IP"
                break
              else
                echo "Attempt $i/$MAX_ATTEMPTS: LoadBalancer IP not assigned yet. Waiting $SLEEP_SECONDS seconds..."
                sleep $SLEEP_SECONDS
              fi
            done
          fi

          SHORT_NAME=${DOMAIN%.$DNS_ZONE}
          echo "Updating DNS record for $DOMAIN -> $STATIC_IP"
          az network dns record-set a delete -g "$RG" -z "$DNS_ZONE" -n "$SHORT_NAME" --yes || true
          az network dns record-set a create -g "$RG" -z "$DNS_ZONE" -n "$SHORT_NAME" --ttl 60
          az network dns record-set a add-record -g "$RG" -z "$DNS_ZONE" -n "$SHORT_NAME" -a "$STATIC_IP" --ttl 60
          echo "DNS updated successfully!"

      - name: Output Argo CD URL
        run: |
          echo "üåê Argo CD URL: https://${{ secrets.PUBLIC_DOMAIN }}"
          echo "üîë Username: admin"
          echo "üîë Password: ${{ secrets.ARGOCD_ADMIN_PASSWORD }}"
